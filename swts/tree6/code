public void expandToDepth(TreeItem item, int targetDepth, int currentDepth) {
    // 현재 깊이가 목표 깊이보다 작으면 확장
    if (currentDepth < targetDepth) {
        item.setExpanded(true);
        for (TreeItem child : item.getItems()) {
            expandToDepth(child, targetDepth, currentDepth + 1);
        }
    } else {
        // 목표 깊이에 도달한 경우 하위 항목을 닫음
        item.setExpanded(false);
    }
}

public void collapseToDepth(Tree tree, int depth) {
    for (TreeItem item : tree.getItems()) {
        expandToDepth(item, depth, 0); // 깊이 설정을 위해 초기 깊이를 0으로 설정
    }
}


collapseToDepth(tree, 2);

--------------------

import java.text.Collator;
import java.util.*;

class Item {
    String name;

    Item(String name) {
        this.name = name;
    }
}

public class ItemSorter {
    public static void main(String[] args) {
        Map<String, Item> map = new HashMap<>();
        map.put("1", new Item("abce65"));
        map.put("2", new Item("abcd65"));
        map.put("3", new Item("abcd7"));
        map.put("4", new Item("abcd_12"));
        map.put("5", new Item("abc d-12"));

        List<Item> items = new ArrayList<>(map.values());
        items.sort(new ItemComparator());

        for (Item item : items) {
            System.out.println(item.name);
        }
    }

    static class ItemComparator implements Comparator<Item> {
        @Override
        public int compare(Item o1, Item o2) {
            String name1 = normalize(o1.name);
            String name2 = normalize(o2.name);

            int result = name1.compareTo(name2);
            if (result == 0) {
                return extractNumbers(o1.name).compareTo(extractNumbers(o2.name));
            }
            return result;
        }

        private String normalize(String str) {
            // 특수문자, 공백, 대소문자 구분 없이 문자열 정규화
            return str.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
        }

        private List<Integer> extractNumbers(String str) {
            List<Integer> numbers = new ArrayList<>();
            Scanner scanner = new Scanner(str);
            while (scanner.findInLine("\\d+") != null) {
                numbers.add(scanner.match().group().length());
            }
            return numbers;


            Map<String, Item> sortedMap = new LinkedHashMap<>();
for (Item item : items) {
    for (Map.Entry<String, Item> entry : map.entrySet()) {
        if (entry.getValue().equals(item)) {
            sortedMap.put(entry.getKey(), item);
            break;
        }
    }
}
------


private int compareNumbers(String str1, String str2) {
    List<Integer> numbers1 = extractNumbers(str1);
    List<Integer> numbers2 = extractNumbers(str2);

    for (int i = 0; i < Math.min(numbers1.size(), numbers2.size()); i++) {
        int cmp = numbers1.get(i).compareTo(numbers2.get(i));
        if (cmp != 0) {
            return cmp;
        }
    }
    return Integer.compare(numbers1.size(), numbers2.size());
}

private List<Integer> extractNumbers(String str) {
    List<Integer> numbers = new ArrayList<>();
    Matcher matcher = Pattern.compile("\\d+").matcher(str);
    while (matcher.find()) {
        numbers.add(Integer.parseInt(matcher.group()));
    }
    return numbers;
}
}


----------


package org.yslee;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class SortTest {

    public static void main(String[] args) {
        List<Node> list = new ArrayList<>();
        Node node = new Node("3");
        list.add(node);

        Node node2 = new Node("1");
        node.next = node2;

        Node node3 = new Node("4");
        node2.next = node3;

        Node node4 = new Node("2");
        node3.next = node4;

        addChildren(node2, "2-3", "2-1", "2-2");
        addChildren(node3, "3-2", "3-3", "3-1");

        // 더 깊은 뎁스의 자식 노드 추가
        Node node2_1 = node2.childList.get(1); // "2-1"
        addChildren(node2_1, "2-1-2", "2-1-1", "2-1-3");

        Node node3_2 = node3.childList.get(0); // "3-2"
        addChildren(node3_2, "3-2-3", "3-2-1", "3-2-2");

        // 데이터 정렬
        List<String> allData = new ArrayList<>();
        collectData(list, allData);
        Collections.sort(allData);

        // 정렬된 데이터 출력
        for (String data : allData) {
            System.out.println(data);
        }
    }

    static void addChildren(Node node, String... data) {
        for (String d : data) {
            node.addChild(new Node(d));
        }
    }

    // 모든 데이터를 수집하는 메서드 (재귀 호출)
    static void collectData(List<Node> nodeList, List<String> allData) {
        for (Node node : nodeList) {
            collectData(node, allData);
        }
    }

    static void collectData(Node node, List<String> allData) {
        if (node == null) {
            return;
        }
        allData.add(node.data);
        if (node.childList != null) {
            for (Node child : node.childList) {
                collectData(child, allData);
            }
        }
        collectData(node.next, allData);
    }

    static class Node {
        String data;
        Node next;
        List<Node> childList;

        Node(String data) {
            this.data = data;
        }

        void addChild(Node node) {
            if (childList == null) {
                childList = new ArrayList<>();
            }
            childList.add(node);
        }
    }
}



----------------


static class AlphanumericComparator implements Comparator<String> {
    @Override
    public int compare(String s1, String s2) {
        // 대소문자, 공백, 언더바 등 제거
        s1 = s1.replaceAll("[_\\s]", "").toLowerCase();
        s2 = s2.replaceAll("[_\\s]", "").toLowerCase();

        String[] parts1 = s1.split("(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)");
        String[] parts2 = s2.split("(?<=\\D)(?=\\d)|(?<=\\d)(?=\\D)");
        int length = Math.min(parts1.length, parts2.length);
        for (int i = 0; i < length; i++) {
            int result = parts1[i].compareTo(parts2[i]);
            if (result != 0) {
                if (parts1[i].matches("\\d+") && parts2[i].matches("\\d+")) {
                    result = Integer.compare(Integer.parseInt(parts1[i]), Integer.parseInt(parts2[i]));
                }
                return result;
            }
        }
        return Integer.compare(parts1.length, parts2.length);
    }
}
